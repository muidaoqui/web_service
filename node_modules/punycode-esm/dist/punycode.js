import { checkOverflow, rangeError } from '#errors';
const maxInt = 0x7fffffff;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = '-';
const baseMinusTMin = base - tMin;
const regexNonASCII = /[^\0-\u007E]/u;
const regexSeparators = /[\u002E\u3002\uFF0E\uFF61]/gu;
const mapDomain = (domain, callback)=>{
    const [first, ...rest] = domain.split('@');
    let result;
    let toEncode;
    if (rest.length > 0) {
        result = `${first}@`;
        toEncode = rest.join('@');
    } else {
        result = '';
        toEncode = first;
    }
    const labels = toEncode.split(regexSeparators);
    const encoded = labels.map((x)=>callback(x)).join('.');
    return result + encoded;
};
export const ucs2Decode = (string)=>{
    const output = [];
    let counter = 0;
    while(counter < string.length){
        const value = string.charCodeAt(counter);
        ++counter;
        if (value >= 0xd800 && value <= 0xdbff && counter < string.length) {
            const extra = string.charCodeAt(counter);
            ++counter;
            if ((extra & 0xfc00) === 0xdc00) {
                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
            } else {
                output.push(value);
                --counter;
            }
        } else {
            output.push(value);
        }
    }
    return output;
};
export const ucs2Encode = (codePoints)=>String.fromCodePoint(...codePoints);
const basicToDigit = (codePoint)=>{
    if (codePoint - 0x30 < 0x0a) {
        return codePoint - 0x16;
    }
    if (codePoint - 0x41 < 0x1a) {
        return codePoint - 0x41;
    }
    if (codePoint - 0x61 < 0x1a) {
        return codePoint - 0x61;
    }
    return base;
};
const digitToBasic = (digit)=>{
    const plus22 = digit + 22;
    return digit < 26 ? plus22 + 75 : plus22;
};
const adapt = (delta, numPoints, firstTime)=>{
    let k = 0;
    let newDelta = firstTime ? Math.floor(delta / damp) : delta >> 1;
    newDelta += Math.floor(newDelta / numPoints);
    const minCheck = baseMinusTMin * tMax >> 1;
    while(newDelta > minCheck){
        newDelta = Math.floor(newDelta / baseMinusTMin);
        k += base;
    }
    return Math.floor(k + (baseMinusTMin + 1) * newDelta / (newDelta + skew));
};
export const decode = (input)=>{
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
        basic = 0;
    }
    for(let j = 0; j < basic; ++j){
        const codePoint = input.codePointAt(j);
        if (codePoint >= 0x80) {
            rangeError('not-basic');
        }
        output.push(codePoint);
    }
    let index = basic > 0 ? basic + 1 : 0;
    while(index < inputLength){
        const oldi = i;
        let w = 1;
        let k = base;
        while(true){
            checkOverflow(index, inputLength, {
                gte: true,
                error: 'invalid-input'
            });
            const digit = basicToDigit(input.codePointAt(index));
            ++index;
            checkOverflow(digit, base, {
                gte: true
            });
            checkOverflow(digit, Math.floor((maxInt - i) / w));
            i += digit * w;
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
                break;
            }
            const baseMinusT = base - t;
            checkOverflow(w, Math.floor(maxInt / baseMinusT));
            w *= baseMinusT;
            k += base;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi === 0);
        checkOverflow(Math.floor(i / out), maxInt - n);
        n += Math.floor(i / out);
        i %= out;
        output.splice(i, 0, n);
        ++i;
    }
    return String.fromCodePoint(...output);
};
export const encode = (input)=>{
    const output = [];
    const decodedInput = ucs2Decode(input);
    const inputLength = decodedInput.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of decodedInput){
        if (currentValue < 0x80) {
            output.push(String.fromCodePoint(currentValue));
        }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
        output.push(delimiter);
    }
    while(handledCPCount < inputLength){
        let m = maxInt;
        for (const currentValue of decodedInput){
            if (currentValue >= n && currentValue < m) {
                m = currentValue;
            }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        checkOverflow(m - n, Math.floor((maxInt - delta) / handledCPCountPlusOne));
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of decodedInput){
            if (currentValue < n) {
                ++delta;
                checkOverflow(delta, maxInt);
            }
            if (currentValue === n) {
                let q = delta;
                let k = base;
                while(true){
                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q < t) {
                        break;
                    }
                    const qMinusT = q - t;
                    const baseMinusT = base - t;
                    output.push(String.fromCodePoint(digitToBasic(t + qMinusT % baseMinusT)));
                    q = Math.floor(qMinusT / baseMinusT);
                    k += base;
                }
                output.push(String.fromCodePoint(digitToBasic(q)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
                delta = 0;
                ++handledCPCount;
            }
        }
        ++delta;
        ++n;
    }
    return output.join('');
};
export const toUnicode = (input)=>mapDomain(input, (str)=>str.startsWith('xn--') ? decode(str.slice(4).toLowerCase()) : str);
export const toASCII = (input)=>mapDomain(input, (string)=>regexNonASCII.test(string) ? `xn--${encode(string)}` : string);

//# sourceMappingURL=punycode.js.map